import sys
import numpy as np

def R_square_imputation_quality_metric(posteriori):
        """
        >>> R_square_imputation_quality_metric(((0.333, 0.333, 0.333), (1.0, 0.0, 0.0)))
        0.66755585195065015
        """
        observed = [(2.0*x[0]) + x[1] for x in posteriori]
        observed_mean = np.mean(observed)
        observed_variance = np.var(observed)

        p = observed_mean / 2.0
        p_all = 2.0 * p * (1.0 - p)

        return observed_variance / p_all

def pow2(x):
        return x*x

def imputation_r_square_hat(posteriori):
	"""
	>>> print r_square_hat([(0.3333333, 0.3333333, 0.3333333), (1.0, 0.0, 0.0)])
	0.428571367347
	"""

	n=float( len(posteriori))
	meanAB = sum([x[1] for x in posteriori])
	meanBB = sum([x[2] for x in posteriori])

	sumX2 = sum([x[1] + (4.0 *x[2]) for x in posteriori])
	sumXbar2 = sum([(x[1] + (2.0 * x[2]))**2.0 for x in posteriori])
	meanX = (meanAB+2.*meanBB)/n
	rsqHat_denom = sumX2/n-pow2(meanX)

	if rsqHat_denom == 0.0:
		return 'NaN'

	rSqHat = (sumXbar2/n-pow2(meanX))/rsqHat_denom

	return rSqHat


from itertools import izip

def imputation_allelic_R2(
	dosage = None #A list of genotype probalities as generated by imputation software. For example: [[0, 0.9612, 0.0388], [0.7106, 0.2554, 0.034], [0, 0.008, 0.992], [0.9424, 0.057, 0.0006]]
):
	"""
	>>> imputation_allelic_R2([[0, 0.9612, 0.0388], [0.7106, 0.2554, 0.034], [0, 0.008, 0.992], [0.9424, 0.057, 0.0006]])
	0.8384421381338543
	"""
	
	samples_n = len(dosage)

	#---------------------Initializing Allelic R^2-----------------------
	Sum_ZiUi = 0.0
	Sum_Ui = 0.0
	Sum_Zi = 0.0
	Sum_Zi2 = 0.0
	Sum_Wi = 0.0
	#-------------------------------------------------------------------

	for AA_Aa_aa in dosage:

		#---------------------Calculating Allelic R2--------------------
		argmax_1 = max(izip(AA_Aa_aa, xrange(len(AA_Aa_aa))))[1] #This is argmax maybe us numpy instead?
		Zi = argmax_1
		Yi_1 = AA_Aa_aa[1]
		Yi_2 = AA_Aa_aa[2]
		Ui = Yi_1 + (2.0 * Yi_2)
		Wi = Yi_1 + (4.0 * Yi_2)
		Sum_ZiUi += Zi*Ui
		Sum_Ui += Ui
		Sum_Zi += Zi
		Sum_Zi2 += Zi**2.0
		Sum_Wi += Wi
		#---------------------------------------------------------------
		
	R2_nominator = ( ( Sum_ZiUi - ((1.0/samples_n)*(Sum_Ui*Sum_Zi)) )**2.0 )
	R2_denominator = ( (Sum_Wi - (1.0/samples_n) * (Sum_Ui)**2.0 ) * (Sum_Zi2 - (1.0/samples_n) * (Sum_Zi)**2.0) )

	if R2_nominator < 0.000001 and R2_denominator < 0.000001: R2 = "NaN"
	else: R2 = R2_nominator / R2_denominator

	return R2

def imputation_quality_metrics_minimac_prob(prob_transposed_filenames, output_filename, methods):
	"""
	#Example:
	imputation_quality_metrics_minimac_prob(
        	['/target/gpfs2/gcc/groups/gonl/projects/imputationBenchmarking/imputationResult/lifelines_MinimacV2_refGoNLv4/chunk9-chr2_sampleChunk9.imputed.prob.transposed'], 
        	'output',
        	['PLINK', 'QUICKTEST', 'BEAGLE'],
        )
	"""

	prob_files = [open(filename) for filename in prob_transposed_filenames]

	output_file = open(output_filename, 'w')
	header = []
	if 'PLINK' in methods:
		header += ['PLINK']
	if 'QUICKTEST' in methods:
		header += ['QUICKTEST']
	if 'BEAGLE' in methods:
		header += ['BEAGLE']

	if not header:
		raise Exception('No method to compute')

	#Ignore two first lines
	_ = [(file.readline(), file.readline()) for file in prob_files]

	lc = 0
	while True:
		line1 = [ file.readline() for file in prob_files]

		if '' in line1:
			break

		line2 = [ file.readline() for file in prob_files]

		#Concat lines
		line1, line2 = [reduce(lambda x,y: x+y, line) for line in [line1, line2]]

		prob1, prob2 = [ [float(x) for x in line.replace('\n', '').split()]  for line in [line1, line2]]

		prob3 = [ max(1.0-x-y, 0.0) for x,y in zip(prob1, prob2)]

		posteriori = zip(prob1, prob2, prob3)
		output_line = []

		if 'PLINK' in methods:
			output_line += [str(R_square_imputation_quality_metric(posteriori))]
		if 'QUICKTEST' in methods:
			output_line += [str(imputation_r_square_hat(posteriori))]
		if 'BEAGLE' in methods:
			output_line += [str(imputation_allelic_R2(posteriori))]

		output_file.write(str.join('\t', output_line) + '\n')

		lc += 1

		if lc % 1000 == 0:
			print "Lines:", lc


	output_file.close()
	_ = [file.close() for file in prob_files]

if __name__ == '__main__':

	usage = """
/target/gpfs2/gcc/tools/Python-2.7.3/bin/python imputation_quality_metrics.py -inputs /target/gpfs2/gcc/groups/gonl/projects/imputationBenchmarking/imputationResult/lifelines_MinimacV2_refGoNLv4/chunk9-chr2_sampleChunk9.imputed.prob.transposed -output output -methods PLINK,QUICKTEST,BEAGLE
"""
	prob_transposed_filenames, output_filename, methods = (False, False, False)

	for index, value in enumerate(sys.argv):
		if value == '-inputs':
			prob_transposed_filenames = sys.argv[index+1].split(',')
		elif value == '-output':
			output_filename = sys.argv[index+1]
		elif value == '-methods':
			methods = sys.argv[index+1].split(',')

	if False in [prob_transposed_filenames, output_filename, methods]:
		print usage
		raise Exception('Invalid options')

	imputation_quality_metrics_minimac_prob(prob_transposed_filenames, output_filename, methods)


